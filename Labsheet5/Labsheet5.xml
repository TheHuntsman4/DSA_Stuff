<?xml version="1.0" encoding="UTF-8"?>
<indexing>
 <object alt="" name="Image1" object_type="graphic"/>
 <object alt="" name="Image2" object_type="graphic"/>
 <object alt="" name="Image3" object_type="graphic"/>
 <object alt="" name="Image4" object_type="graphic"/>
 <object alt="" name="Image5" object_type="graphic"/>
 <object alt="" name="Image6" object_type="graphic"/>
 <object alt="" name="Image7" object_type="graphic"/>
 <object alt="" name="Image8" object_type="graphic"/>
 <object alt="" name="Image9" object_type="graphic"/>
 <object alt="" name="Image10" object_type="graphic"/>
 <object alt="" name="Image11" object_type="graphic"/>
 <object alt="" name="Image12" object_type="graphic"/>
 <object alt="" name="Image13" object_type="graphic"/>
 <object alt="" name="Image14" object_type="graphic"/>
 <object alt="" name="Image15" object_type="graphic"/>
 <object alt="" name="Image16" object_type="graphic"/>
 <object alt="" name="Image17" object_type="graphic"/>
 <object alt="" name="Image18" object_type="graphic"/>
 <paragraph index="63" node_type="writer">22AIE112 Data Structure And Algorithms</paragraph>
 <paragraph index="64" node_type="writer">Labsheet 5</paragraph>
 <paragraph index="65" node_type="writer">Stack</paragraph>
 <paragraph index="66" node_type="writer">Date : 9/7/2023 				Roll No: AM.EN.U4AIE22009</paragraph>
 <paragraph index="69" node_type="writer">1.Implement the following operations in stack data structure: Push, pop, peek using Array</paragraph>
 <paragraph index="71" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="73" node_type="writer">#define MAX_SIZE 100</paragraph>
 <paragraph index="75" node_type="writer">int stack[MAX_SIZE];</paragraph>
 <paragraph index="76" node_type="writer">int top = -1;</paragraph>
 <paragraph index="78" node_type="writer">void push(int value) {</paragraph>
 <paragraph index="79" node_type="writer">if (top == MAX_SIZE - 1) {</paragraph>
 <paragraph index="80" node_type="writer">printf(&quot;Stack overflow: Cannot push element\n&quot;);</paragraph>
 <paragraph index="81" node_type="writer">return;</paragraph>
 <paragraph index="82" node_type="writer">}</paragraph>
 <paragraph index="83" node_type="writer">top++;</paragraph>
 <paragraph index="84" node_type="writer">stack[top] = value;</paragraph>
 <paragraph index="85" node_type="writer">printf(&quot;Pushed %d onto the stack\n&quot;, value);</paragraph>
 <paragraph index="86" node_type="writer">}</paragraph>
 <paragraph index="88" node_type="writer">void pop() {</paragraph>
 <paragraph index="89" node_type="writer">if (top == -1) {</paragraph>
 <paragraph index="90" node_type="writer">printf(&quot;Stack underflow: Cannot pop element\n&quot;);</paragraph>
 <paragraph index="91" node_type="writer">return;</paragraph>
 <paragraph index="92" node_type="writer">}</paragraph>
 <paragraph index="93" node_type="writer">int poppedValue = stack[top];</paragraph>
 <paragraph index="94" node_type="writer">top--;</paragraph>
 <paragraph index="95" node_type="writer">printf(&quot;Popped %d from the stack\n&quot;, poppedValue);</paragraph>
 <paragraph index="96" node_type="writer">}</paragraph>
 <paragraph index="98" node_type="writer">int peek() {</paragraph>
 <paragraph index="99" node_type="writer">if (top == -1) {</paragraph>
 <paragraph index="100" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="101" node_type="writer">return -1;</paragraph>
 <paragraph index="102" node_type="writer">}</paragraph>
 <paragraph index="103" node_type="writer">return stack[top];</paragraph>
 <paragraph index="104" node_type="writer">}</paragraph>
 <paragraph index="106" node_type="writer">void displayStack() {</paragraph>
 <paragraph index="107" node_type="writer">if (top == -1) {</paragraph>
 <paragraph index="108" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="109" node_type="writer">return;</paragraph>
 <paragraph index="110" node_type="writer">}</paragraph>
 <paragraph index="111" node_type="writer">printf(&quot;Stack elements: &quot;);</paragraph>
 <paragraph index="112" node_type="writer">for (int i = 0; i &lt;= top; i++) {</paragraph>
 <paragraph index="113" node_type="writer">printf(&quot;%d &quot;, stack[i]);</paragraph>
 <paragraph index="114" node_type="writer">}</paragraph>
 <paragraph index="115" node_type="writer">printf(&quot;\n&quot;);</paragraph>
 <paragraph index="116" node_type="writer">}</paragraph>
 <paragraph index="118" node_type="writer">int main() {</paragraph>
 <paragraph index="119" node_type="writer">int choice, value;</paragraph>
 <paragraph index="120" node_type="writer">do {</paragraph>
 <paragraph index="121" node_type="writer">printf(&quot;\nStack Operations\n&quot;);</paragraph>
 <paragraph index="122" node_type="writer">printf(&quot;1. Push\n&quot;);</paragraph>
 <paragraph index="123" node_type="writer">printf(&quot;2. Pop\n&quot;);</paragraph>
 <paragraph index="124" node_type="writer">printf(&quot;3. Peek\n&quot;);</paragraph>
 <paragraph index="125" node_type="writer">printf(&quot;4. Display Stack\n&quot;);</paragraph>
 <paragraph index="126" node_type="writer">printf(&quot;0. Exit\n&quot;);</paragraph>
 <paragraph index="127" node_type="writer">printf(&quot;Enter your choice: &quot;);</paragraph>
 <paragraph index="128" node_type="writer">scanf(&quot;%d&quot;, &amp;choice);</paragraph>
 <paragraph index="129" node_type="writer">switch (choice) {</paragraph>
 <paragraph index="130" node_type="writer">case 0:</paragraph>
 <paragraph index="131" node_type="writer">printf(&quot;Exiting the program\n&quot;);</paragraph>
 <paragraph index="132" node_type="writer">break;</paragraph>
 <paragraph index="133" node_type="writer">case 1:</paragraph>
 <paragraph index="134" node_type="writer">printf(&quot;Enter the value to push: &quot;);</paragraph>
 <paragraph index="135" node_type="writer">scanf(&quot;%d&quot;, &amp;value);</paragraph>
 <paragraph index="136" node_type="writer">push(value);</paragraph>
 <paragraph index="137" node_type="writer">break;</paragraph>
 <paragraph index="138" node_type="writer">case 2:</paragraph>
 <paragraph index="139" node_type="writer">pop();</paragraph>
 <paragraph index="140" node_type="writer">break;</paragraph>
 <paragraph index="141" node_type="writer">case 3:</paragraph>
 <paragraph index="142" node_type="writer">printf(&quot;Top of the stack: %d\n&quot;, peek());</paragraph>
 <paragraph index="143" node_type="writer">break;</paragraph>
 <paragraph index="144" node_type="writer">case 4:</paragraph>
 <paragraph index="145" node_type="writer">displayStack();</paragraph>
 <paragraph index="146" node_type="writer">break;</paragraph>
 <paragraph index="147" node_type="writer">default:</paragraph>
 <paragraph index="148" node_type="writer">printf(&quot;Invalid choice\n&quot;);</paragraph>
 <paragraph index="149" node_type="writer">}</paragraph>
 <paragraph index="150" node_type="writer">} while (choice != 0);</paragraph>
 <paragraph index="151" node_type="writer">return 0;</paragraph>
 <paragraph index="152" node_type="writer">}</paragraph>
 <paragraph index="205" node_type="writer">2.Implement the following operations in stack data structure: Push, pop, peek using Linked list</paragraph>
 <paragraph index="208" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="209" node_type="writer">#include &lt;stdlib.h&gt;</paragraph>
 <paragraph index="211" node_type="writer">struct Node {</paragraph>
 <paragraph index="212" node_type="writer">int data;</paragraph>
 <paragraph index="213" node_type="writer">struct Node* next;</paragraph>
 <paragraph index="214" node_type="writer">};</paragraph>
 <paragraph index="216" node_type="writer">struct Node* top = NULL;</paragraph>
 <paragraph index="218" node_type="writer">void push(int value) {</paragraph>
 <paragraph index="219" node_type="writer">struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));</paragraph>
 <paragraph index="220" node_type="writer">if (newNode == NULL) {</paragraph>
 <paragraph index="221" node_type="writer">printf(&quot;Memory allocation failed. Unable to push element.\n&quot;);</paragraph>
 <paragraph index="222" node_type="writer">return;</paragraph>
 <paragraph index="223" node_type="writer">}</paragraph>
 <paragraph index="224" node_type="writer">newNode-&gt;data = value;</paragraph>
 <paragraph index="225" node_type="writer">newNode-&gt;next = top;</paragraph>
 <paragraph index="226" node_type="writer">top = newNode;</paragraph>
 <paragraph index="227" node_type="writer">printf(&quot;Pushed %d onto the stack\n&quot;, value);</paragraph>
 <paragraph index="228" node_type="writer">}</paragraph>
 <paragraph index="230" node_type="writer">void pop() {</paragraph>
 <paragraph index="231" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="232" node_type="writer">printf(&quot;Stack underflow: Cannot pop element\n&quot;);</paragraph>
 <paragraph index="233" node_type="writer">return;</paragraph>
 <paragraph index="234" node_type="writer">}</paragraph>
 <paragraph index="235" node_type="writer">struct Node* temp = top;</paragraph>
 <paragraph index="236" node_type="writer">int poppedValue = temp-&gt;data;</paragraph>
 <paragraph index="237" node_type="writer">top = top-&gt;next;</paragraph>
 <paragraph index="238" node_type="writer">free(temp);</paragraph>
 <paragraph index="239" node_type="writer">printf(&quot;Popped %d from the stack\n&quot;, poppedValue);</paragraph>
 <paragraph index="240" node_type="writer">}</paragraph>
 <paragraph index="242" node_type="writer">int peek() {</paragraph>
 <paragraph index="243" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="244" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="245" node_type="writer">return -1;</paragraph>
 <paragraph index="246" node_type="writer">}</paragraph>
 <paragraph index="247" node_type="writer">return top-&gt;data;</paragraph>
 <paragraph index="248" node_type="writer">}</paragraph>
 <paragraph index="249" node_type="writer">
</paragraph>
 <paragraph index="250" node_type="writer">void displayStack() {</paragraph>
 <paragraph index="251" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="252" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="253" node_type="writer">return;</paragraph>
 <paragraph index="254" node_type="writer">}</paragraph>
 <paragraph index="255" node_type="writer">printf(&quot;Stack elements: &quot;);</paragraph>
 <paragraph index="256" node_type="writer">struct Node* current = top;</paragraph>
 <paragraph index="257" node_type="writer">while (current != NULL) {</paragraph>
 <paragraph index="258" node_type="writer">printf(&quot;%d &quot;, current-&gt;data);</paragraph>
 <paragraph index="259" node_type="writer">current = current-&gt;next;</paragraph>
 <paragraph index="260" node_type="writer">}</paragraph>
 <paragraph index="261" node_type="writer">printf(&quot;\n&quot;);</paragraph>
 <paragraph index="262" node_type="writer">}</paragraph>
 <paragraph index="264" node_type="writer">int main() {</paragraph>
 <paragraph index="265" node_type="writer">int choice, value;</paragraph>
 <paragraph index="266" node_type="writer">do {</paragraph>
 <paragraph index="267" node_type="writer">printf(&quot;\nStack Operations\n&quot;);</paragraph>
 <paragraph index="268" node_type="writer">printf(&quot;1. Push\n&quot;);</paragraph>
 <paragraph index="269" node_type="writer">printf(&quot;2. Pop\n&quot;);</paragraph>
 <paragraph index="270" node_type="writer">printf(&quot;3. Peek\n&quot;);</paragraph>
 <paragraph index="271" node_type="writer">printf(&quot;4. Display Stack\n&quot;);</paragraph>
 <paragraph index="272" node_type="writer">printf(&quot;0. Exit\n&quot;);</paragraph>
 <paragraph index="273" node_type="writer">printf(&quot;Enter your choice: &quot;);</paragraph>
 <paragraph index="274" node_type="writer">scanf(&quot;%d&quot;, &amp;choice);</paragraph>
 <paragraph index="275" node_type="writer">switch (choice) {</paragraph>
 <paragraph index="276" node_type="writer">case 0:</paragraph>
 <paragraph index="277" node_type="writer">printf(&quot;Exiting the program\n&quot;);</paragraph>
 <paragraph index="278" node_type="writer">break;</paragraph>
 <paragraph index="279" node_type="writer">case 1:</paragraph>
 <paragraph index="280" node_type="writer">printf(&quot;Enter the value to push: &quot;);</paragraph>
 <paragraph index="281" node_type="writer">scanf(&quot;%d&quot;, &amp;value);</paragraph>
 <paragraph index="282" node_type="writer">push(value);</paragraph>
 <paragraph index="283" node_type="writer">break;</paragraph>
 <paragraph index="284" node_type="writer">case 2:</paragraph>
 <paragraph index="285" node_type="writer">pop();</paragraph>
 <paragraph index="286" node_type="writer">break;</paragraph>
 <paragraph index="287" node_type="writer">case 3:</paragraph>
 <paragraph index="288" node_type="writer">printf(&quot;Top of the stack: %d\n&quot;, peek());</paragraph>
 <paragraph index="289" node_type="writer">break;</paragraph>
 <paragraph index="290" node_type="writer">case 4:</paragraph>
 <paragraph index="291" node_type="writer">displayStack();</paragraph>
 <paragraph index="292" node_type="writer">break;</paragraph>
 <paragraph index="293" node_type="writer">default:</paragraph>
 <paragraph index="294" node_type="writer">printf(&quot;Invalid choice\n&quot;);</paragraph>
 <paragraph index="295" node_type="writer">}</paragraph>
 <paragraph index="296" node_type="writer">} while (choice != 0);</paragraph>
 <paragraph index="297" node_type="writer">return 0;</paragraph>
 <paragraph index="298" node_type="writer">}</paragraph>
 <paragraph index="305" node_type="writer">3.Implement a function getminElement() to return the minimum element in a stack.</paragraph>
 <paragraph index="308" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="309" node_type="writer">#include &lt;stdlib.h&gt;</paragraph>
 <paragraph index="311" node_type="writer">struct Node {</paragraph>
 <paragraph index="312" node_type="writer">int data;</paragraph>
 <paragraph index="313" node_type="writer">int min;</paragraph>
 <paragraph index="314" node_type="writer">struct Node* next;</paragraph>
 <paragraph index="315" node_type="writer">};</paragraph>
 <paragraph index="317" node_type="writer">struct Node* top = NULL;</paragraph>
 <paragraph index="319" node_type="writer">void push(int value) {</paragraph>
 <paragraph index="320" node_type="writer">struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));</paragraph>
 <paragraph index="321" node_type="writer">if (newNode == NULL) {</paragraph>
 <paragraph index="322" node_type="writer">printf(&quot;Memory allocation failed. Unable to push element.\n&quot;);</paragraph>
 <paragraph index="323" node_type="writer">return;</paragraph>
 <paragraph index="324" node_type="writer">}</paragraph>
 <paragraph index="325" node_type="writer">newNode-&gt;data = value;</paragraph>
 <paragraph index="326" node_type="writer">newNode-&gt;next = top;</paragraph>
 <paragraph index="327" node_type="writer">top = newNode;</paragraph>
 <paragraph index="328" node_type="writer">if (top-&gt;next == NULL || value &lt; top-&gt;next-&gt;min)</paragraph>
 <paragraph index="329" node_type="writer">top-&gt;min = value;</paragraph>
 <paragraph index="330" node_type="writer">else</paragraph>
 <paragraph index="331" node_type="writer">top-&gt;min = top-&gt;next-&gt;min;</paragraph>
 <paragraph index="332" node_type="writer">printf(&quot;Pushed %d onto the stack\n&quot;, value);</paragraph>
 <paragraph index="333" node_type="writer">}</paragraph>
 <paragraph index="335" node_type="writer">void pop() {</paragraph>
 <paragraph index="336" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="337" node_type="writer">printf(&quot;Stack underflow: Cannot pop element\n&quot;);</paragraph>
 <paragraph index="338" node_type="writer">return;</paragraph>
 <paragraph index="339" node_type="writer">}</paragraph>
 <paragraph index="340" node_type="writer">struct Node* temp = top;</paragraph>
 <paragraph index="341" node_type="writer">int poppedValue = temp-&gt;data;</paragraph>
 <paragraph index="342" node_type="writer">top = top-&gt;next;</paragraph>
 <paragraph index="343" node_type="writer">free(temp);</paragraph>
 <paragraph index="344" node_type="writer">printf(&quot;Popped %d from the stack\n&quot;, poppedValue);</paragraph>
 <paragraph index="345" node_type="writer">}</paragraph>
 <paragraph index="347" node_type="writer">int peek() {</paragraph>
 <paragraph index="348" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="349" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="350" node_type="writer">return -1;</paragraph>
 <paragraph index="351" node_type="writer">}</paragraph>
 <paragraph index="352" node_type="writer">return top-&gt;data;</paragraph>
 <paragraph index="353" node_type="writer">}</paragraph>
 <paragraph index="355" node_type="writer">int getMin() {</paragraph>
 <paragraph index="356" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="357" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="358" node_type="writer">return -1;</paragraph>
 <paragraph index="359" node_type="writer">}</paragraph>
 <paragraph index="360" node_type="writer">return top-&gt;min;</paragraph>
 <paragraph index="361" node_type="writer">}</paragraph>
 <paragraph index="363" node_type="writer">struct Node* copyStack() {</paragraph>
 <paragraph index="364" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="365" node_type="writer">printf(&quot;Stack is empty. Cannot copy.\n&quot;);</paragraph>
 <paragraph index="366" node_type="writer">return NULL;</paragraph>
 <paragraph index="367" node_type="writer">}</paragraph>
 <paragraph index="368" node_type="writer">struct Node* originalCurrent = top;</paragraph>
 <paragraph index="369" node_type="writer">struct Node* duplicateTop = NULL;</paragraph>
 <paragraph index="370" node_type="writer">struct Node* duplicateCurrent = NULL;</paragraph>
 <paragraph index="371" node_type="writer">while (originalCurrent != NULL) {</paragraph>
 <paragraph index="372" node_type="writer">struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));</paragraph>
 <paragraph index="373" node_type="writer">if (newNode == NULL) {</paragraph>
 <paragraph index="374" node_type="writer">printf(&quot;Memory allocation failed. Unable to copy element.\n&quot;);</paragraph>
 <paragraph index="375" node_type="writer">return NULL;</paragraph>
 <paragraph index="376" node_type="writer">}</paragraph>
 <paragraph index="377" node_type="writer">newNode-&gt;data = originalCurrent-&gt;data;</paragraph>
 <paragraph index="378" node_type="writer">newNode-&gt;next = NULL;</paragraph>
 <paragraph index="379" node_type="writer">if (duplicateTop == NULL) {</paragraph>
 <paragraph index="380" node_type="writer">duplicateTop = newNode;</paragraph>
 <paragraph index="381" node_type="writer">duplicateCurrent = newNode;</paragraph>
 <paragraph index="382" node_type="writer">} else {</paragraph>
 <paragraph index="383" node_type="writer">duplicateCurrent-&gt;next = newNode;</paragraph>
 <paragraph index="384" node_type="writer">duplicateCurrent = duplicateCurrent-&gt;next;</paragraph>
 <paragraph index="385" node_type="writer">}</paragraph>
 <paragraph index="386" node_type="writer">originalCurrent = originalCurrent-&gt;next;</paragraph>
 <paragraph index="387" node_type="writer">}</paragraph>
 <paragraph index="388" node_type="writer">return duplicateTop;</paragraph>
 <paragraph index="389" node_type="writer">}</paragraph>
 <paragraph index="391" node_type="writer">void displayStack(struct Node* stack) {</paragraph>
 <paragraph index="392" node_type="writer">if (stack == NULL) {</paragraph>
 <paragraph index="393" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="394" node_type="writer">return;</paragraph>
 <paragraph index="395" node_type="writer">}</paragraph>
 <paragraph index="396" node_type="writer">printf(&quot;Stack elements: &quot;);</paragraph>
 <paragraph index="397" node_type="writer">struct Node* current = stack;</paragraph>
 <paragraph index="398" node_type="writer">while (current != NULL) {</paragraph>
 <paragraph index="399" node_type="writer">printf(&quot;%d &quot;, current-&gt;data);</paragraph>
 <paragraph index="400" node_type="writer">current = current-&gt;next;</paragraph>
 <paragraph index="401" node_type="writer">}</paragraph>
 <paragraph index="402" node_type="writer">printf(&quot;\n&quot;);</paragraph>
 <paragraph index="403" node_type="writer">}</paragraph>
 <paragraph index="405" node_type="writer">int main() {</paragraph>
 <paragraph index="406" node_type="writer">int choice, value;</paragraph>
 <paragraph index="407" node_type="writer">do {</paragraph>
 <paragraph index="408" node_type="writer">printf(&quot;\nStack Operations\n&quot;);</paragraph>
 <paragraph index="409" node_type="writer">printf(&quot;1. Push\n&quot;);</paragraph>
 <paragraph index="410" node_type="writer">printf(&quot;2. Pop\n&quot;);</paragraph>
 <paragraph index="411" node_type="writer">printf(&quot;3. Peek\n&quot;);</paragraph>
 <paragraph index="412" node_type="writer">printf(&quot;4. Get Minimum\n&quot;);</paragraph>
 <paragraph index="413" node_type="writer">printf(&quot;5. Copy Stack\n&quot;);</paragraph>
 <paragraph index="414" node_type="writer">printf(&quot;6. Display Stack\n&quot;);</paragraph>
 <paragraph index="415" node_type="writer">printf(&quot;0. Exit\n&quot;);</paragraph>
 <paragraph index="416" node_type="writer">printf(&quot;Enter your choice: &quot;);</paragraph>
 <paragraph index="417" node_type="writer">scanf(&quot;%d&quot;, &amp;choice);</paragraph>
 <paragraph index="418" node_type="writer">switch (choice) {</paragraph>
 <paragraph index="419" node_type="writer">case 0:</paragraph>
 <paragraph index="420" node_type="writer">printf(&quot;Exiting the program\n&quot;);</paragraph>
 <paragraph index="421" node_type="writer">break;</paragraph>
 <paragraph index="422" node_type="writer">case 1:</paragraph>
 <paragraph index="423" node_type="writer">printf(&quot;Enter the value to push: &quot;);</paragraph>
 <paragraph index="424" node_type="writer">scanf(&quot;%d&quot;, &amp;value);</paragraph>
 <paragraph index="425" node_type="writer">push(value);</paragraph>
 <paragraph index="426" node_type="writer">break;</paragraph>
 <paragraph index="427" node_type="writer">case 2:</paragraph>
 <paragraph index="428" node_type="writer">pop();</paragraph>
 <paragraph index="429" node_type="writer">break;</paragraph>
 <paragraph index="430" node_type="writer">case 3:</paragraph>
 <paragraph index="431" node_type="writer">printf(&quot;Top of the stack: %d\n&quot;, peek());</paragraph>
 <paragraph index="432" node_type="writer">break;</paragraph>
 <paragraph index="433" node_type="writer">case 4:</paragraph>
 <paragraph index="434" node_type="writer">printf(&quot;Minimum element: %d\n&quot;, getMin());</paragraph>
 <paragraph index="435" node_type="writer">break;</paragraph>
 <paragraph index="436" node_type="writer">case 5: {</paragraph>
 <paragraph index="437" node_type="writer">struct Node* duplicateStack = copyStack();</paragraph>
 <paragraph index="438" node_type="writer">printf(&quot;Duplicate stack: &quot;);</paragraph>
 <paragraph index="439" node_type="writer">displayStack(duplicateStack);</paragraph>
 <paragraph index="440" node_type="writer">break;</paragraph>
 <paragraph index="441" node_type="writer">}</paragraph>
 <paragraph index="442" node_type="writer">case 6:</paragraph>
 <paragraph index="443" node_type="writer">displayStack(top);</paragraph>
 <paragraph index="444" node_type="writer">break;</paragraph>
 <paragraph index="445" node_type="writer">default:</paragraph>
 <paragraph index="446" node_type="writer">printf(&quot;Invalid choice\n&quot;);</paragraph>
 <paragraph index="447" node_type="writer">}</paragraph>
 <paragraph index="448" node_type="writer">} while (choice != 0);</paragraph>
 <paragraph index="449" node_type="writer">return 0;</paragraph>
 <paragraph index="450" node_type="writer">}</paragraph>
 <paragraph index="468" node_type="writer">4.Implement a copyStack() function to return a duplicate stack of original stack.</paragraph>
 <paragraph index="491" node_type="writer">Output</paragraph>
 <paragraph index="522" node_type="writer">5.Implement a fucntion to reverse an input string using stack	</paragraph>
 <paragraph index="523" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="524" node_type="writer">#include &lt;stdlib.h&gt;</paragraph>
 <paragraph index="525" node_type="writer">#include &lt;string.h&gt;</paragraph>
 <paragraph index="527" node_type="writer">#define MAX_SIZE 100</paragraph>
 <paragraph index="529" node_type="writer">struct Node {</paragraph>
 <paragraph index="530" node_type="writer">char data;</paragraph>
 <paragraph index="531" node_type="writer">struct Node* next;</paragraph>
 <paragraph index="532" node_type="writer">};</paragraph>
 <paragraph index="534" node_type="writer">struct Node* top = NULL;</paragraph>
 <paragraph index="536" node_type="writer">void push(char value) {</paragraph>
 <paragraph index="537" node_type="writer">struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));</paragraph>
 <paragraph index="538" node_type="writer">if (newNode == NULL) {</paragraph>
 <paragraph index="539" node_type="writer">printf(&quot;Memory allocation failed. Unable to push element.\n&quot;);</paragraph>
 <paragraph index="540" node_type="writer">return;</paragraph>
 <paragraph index="541" node_type="writer">}</paragraph>
 <paragraph index="542" node_type="writer">newNode-&gt;data = value;</paragraph>
 <paragraph index="543" node_type="writer">newNode-&gt;next = top;</paragraph>
 <paragraph index="544" node_type="writer">top = newNode;</paragraph>
 <paragraph index="545" node_type="writer">}</paragraph>
 <paragraph index="547" node_type="writer">char pop() {</paragraph>
 <paragraph index="548" node_type="writer">if (top == NULL) {</paragraph>
 <paragraph index="549" node_type="writer">printf(&quot;Stack underflow: Cannot pop element\n&quot;);</paragraph>
 <paragraph index="550" node_type="writer">return '\0';</paragraph>
 <paragraph index="551" node_type="writer">}</paragraph>
 <paragraph index="552" node_type="writer">struct Node* temp = top;</paragraph>
 <paragraph index="553" node_type="writer">char poppedValue = temp-&gt;data;</paragraph>
 <paragraph index="554" node_type="writer">top = top-&gt;next;</paragraph>
 <paragraph index="555" node_type="writer">free(temp);</paragraph>
 <paragraph index="556" node_type="writer">return poppedValue;</paragraph>
 <paragraph index="557" node_type="writer">}</paragraph>
 <paragraph index="559" node_type="writer">void reverseString(char* str) {</paragraph>
 <paragraph index="560" node_type="writer">int length = strlen(str);</paragraph>
 <paragraph index="561" node_type="writer">for (int i = 0; i &lt; length; i++) {</paragraph>
 <paragraph index="562" node_type="writer">push(str[i]);</paragraph>
 <paragraph index="563" node_type="writer">}</paragraph>
 <paragraph index="564" node_type="writer">for (int i = 0; i &lt; length; i++) {</paragraph>
 <paragraph index="565" node_type="writer">str[i] = pop();</paragraph>
 <paragraph index="566" node_type="writer">}</paragraph>
 <paragraph index="567" node_type="writer">}</paragraph>
 <paragraph index="569" node_type="writer">int main() {</paragraph>
 <paragraph index="570" node_type="writer">char input[MAX_SIZE];</paragraph>
 <paragraph index="571" node_type="writer">printf(&quot;Enter a string: &quot;);</paragraph>
 <paragraph index="572" node_type="writer">fgets(input, sizeof(input), stdin);</paragraph>
 <paragraph index="573" node_type="writer">input[strcspn(input, &quot;\n&quot;)] = '\0'; // Remove trailing newline character</paragraph>
 <paragraph index="574" node_type="writer">printf(&quot;Original string: %s\n&quot;, input);</paragraph>
 <paragraph index="575" node_type="writer">reverseString(input);</paragraph>
 <paragraph index="576" node_type="writer">printf(&quot;Reversed string: %s\n&quot;, input);</paragraph>
 <paragraph index="577" node_type="writer">return 0;</paragraph>
 <paragraph index="578" node_type="writer">}</paragraph>
 <paragraph index="580" node_type="writer">Output</paragraph>
 <paragraph index="583" node_type="writer">6.Given a stack with push(), pop(), isEmpty() operations. Write a function that takes a stack with suitable push, pop and isEmpty operations and modifies it such that the middle element is removed. </paragraph>
 <paragraph index="585" node_type="writer">Example: Input : Stack[] = [1, 2, 3, 4, 5] Output : Stack[] = [1, 2, 4, 5] Input : Stack[] = [1, 2, 3, 4, 5, 6] Output : Stack[] = [1, 2, 4, 5, 6]</paragraph>
 <paragraph index="589" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="590" node_type="writer">#include &lt;stdlib.h&gt;</paragraph>
 <paragraph index="591" node_type="writer">#include &lt;stdbool.h&gt;</paragraph>
 <paragraph index="593" node_type="writer">#define MAX_SIZE 100</paragraph>
 <paragraph index="595" node_type="writer">int stack[MAX_SIZE];</paragraph>
 <paragraph index="596" node_type="writer">int top = -1;</paragraph>
 <paragraph index="598" node_type="writer">void push(int value) {</paragraph>
 <paragraph index="599" node_type="writer">if (top == MAX_SIZE - 1) {</paragraph>
 <paragraph index="600" node_type="writer">printf(&quot;Stack overflow: Cannot push element\n&quot;);</paragraph>
 <paragraph index="601" node_type="writer">return;</paragraph>
 <paragraph index="602" node_type="writer">}</paragraph>
 <paragraph index="603" node_type="writer">top++;</paragraph>
 <paragraph index="604" node_type="writer">stack[top] = value;</paragraph>
 <paragraph index="605" node_type="writer">printf(&quot;Pushed %d onto the stack\n&quot;, value);</paragraph>
 <paragraph index="606" node_type="writer">}</paragraph>
 <paragraph index="608" node_type="writer">int pop() {</paragraph>
 <paragraph index="609" node_type="writer">if (top == -1) {</paragraph>
 <paragraph index="610" node_type="writer">printf(&quot;Stack underflow: Cannot pop element\n&quot;);</paragraph>
 <paragraph index="611" node_type="writer">return -1;</paragraph>
 <paragraph index="612" node_type="writer">}</paragraph>
 <paragraph index="613" node_type="writer">int poppedValue = stack[top];</paragraph>
 <paragraph index="614" node_type="writer">top--;</paragraph>
 <paragraph index="615" node_type="writer">return poppedValue;</paragraph>
 <paragraph index="616" node_type="writer">}</paragraph>
 <paragraph index="618" node_type="writer">bool isEmpty() {</paragraph>
 <paragraph index="619" node_type="writer">return (top == -1);</paragraph>
 <paragraph index="620" node_type="writer">}</paragraph>
 <paragraph index="622" node_type="writer">void removeMiddle() {</paragraph>
 <paragraph index="623" node_type="writer">int size = top + 1;</paragraph>
 <paragraph index="624" node_type="writer">int middle = size / 2;</paragraph>
 <paragraph index="625" node_type="writer">int* aux = (int*)malloc(middle * sizeof(int));</paragraph>
 <paragraph index="626" node_type="writer">if (aux == NULL) {</paragraph>
 <paragraph index="627" node_type="writer">printf(&quot;Memory allocation failed\n&quot;);</paragraph>
 <paragraph index="628" node_type="writer">return;</paragraph>
 <paragraph index="629" node_type="writer">}</paragraph>
 <paragraph index="631" node_type="writer">for (int i = 0; i &lt; middle; i++) {</paragraph>
 <paragraph index="632" node_type="writer">aux[i] = pop();</paragraph>
 <paragraph index="633" node_type="writer">}</paragraph>
 <paragraph index="634" node_type="writer">pop();</paragraph>
 <paragraph index="636" node_type="writer">for (int i = middle - 1; i &gt;= 0; i--) {</paragraph>
 <paragraph index="637" node_type="writer">push(aux[i]);</paragraph>
 <paragraph index="638" node_type="writer">}</paragraph>
 <paragraph index="639" node_type="writer">free(aux);</paragraph>
 <paragraph index="640" node_type="writer">}</paragraph>
 <paragraph index="642" node_type="writer">void displayStack() {</paragraph>
 <paragraph index="643" node_type="writer">if (isEmpty()) {</paragraph>
 <paragraph index="644" node_type="writer">printf(&quot;Stack is empty\n&quot;);</paragraph>
 <paragraph index="645" node_type="writer">return;</paragraph>
 <paragraph index="646" node_type="writer">}</paragraph>
 <paragraph index="647" node_type="writer">printf(&quot;Stack elements: &quot;);</paragraph>
 <paragraph index="648" node_type="writer">for (int i = 0; i &lt;= top; i++) {</paragraph>
 <paragraph index="649" node_type="writer">printf(&quot;%d &quot;, stack[i]);</paragraph>
 <paragraph index="650" node_type="writer">}</paragraph>
 <paragraph index="651" node_type="writer">printf(&quot;\n&quot;);</paragraph>
 <paragraph index="652" node_type="writer">}</paragraph>
 <paragraph index="654" node_type="writer">int main() {</paragraph>
 <paragraph index="655" node_type="writer">int choice, value;</paragraph>
 <paragraph index="656" node_type="writer">do {</paragraph>
 <paragraph index="657" node_type="writer">printf(&quot;\nStack Operations\n&quot;);</paragraph>
 <paragraph index="658" node_type="writer">printf(&quot;1. Push\n&quot;);</paragraph>
 <paragraph index="659" node_type="writer">printf(&quot;2. Pop\n&quot;);</paragraph>
 <paragraph index="660" node_type="writer">printf(&quot;3. Remove Middle Element\n&quot;);</paragraph>
 <paragraph index="661" node_type="writer">printf(&quot;4. Display Stack\n&quot;);</paragraph>
 <paragraph index="662" node_type="writer">printf(&quot;0. Exit\n&quot;);</paragraph>
 <paragraph index="663" node_type="writer">printf(&quot;Enter your choice: &quot;);</paragraph>
 <paragraph index="664" node_type="writer">scanf(&quot;%d&quot;, &amp;choice);</paragraph>
 <paragraph index="665" node_type="writer">switch (choice) {</paragraph>
 <paragraph index="666" node_type="writer">case 0:</paragraph>
 <paragraph index="667" node_type="writer">printf(&quot;Exiting the program\n&quot;);</paragraph>
 <paragraph index="668" node_type="writer">break;</paragraph>
 <paragraph index="669" node_type="writer">case 1:</paragraph>
 <paragraph index="670" node_type="writer">printf(&quot;Enter the value to push: &quot;);</paragraph>
 <paragraph index="671" node_type="writer">scanf(&quot;%d&quot;, &amp;value);</paragraph>
 <paragraph index="672" node_type="writer">push(value);</paragraph>
 <paragraph index="673" node_type="writer">break;</paragraph>
 <paragraph index="674" node_type="writer">case 2:</paragraph>
 <paragraph index="675" node_type="writer">printf(&quot;Popped %d from the stack\n&quot;, pop());</paragraph>
 <paragraph index="676" node_type="writer">break;</paragraph>
 <paragraph index="677" node_type="writer">case 3:</paragraph>
 <paragraph index="678" node_type="writer">removeMiddle();</paragraph>
 <paragraph index="679" node_type="writer">printf(&quot;Middle element removed from the stack\n&quot;);</paragraph>
 <paragraph index="680" node_type="writer">break;</paragraph>
 <paragraph index="681" node_type="writer">case 4:</paragraph>
 <paragraph index="682" node_type="writer">displayStack();</paragraph>
 <paragraph index="683" node_type="writer">break;</paragraph>
 <paragraph index="684" node_type="writer">default:</paragraph>
 <paragraph index="685" node_type="writer">printf(&quot;Invalid choice\n&quot;);</paragraph>
 <paragraph index="686" node_type="writer">}</paragraph>
 <paragraph index="687" node_type="writer">} while (choice != 0);</paragraph>
 <paragraph index="688" node_type="writer">return 0;</paragraph>
 <paragraph index="689" node_type="writer">}</paragraph>
 <paragraph index="691" node_type="writer">Output</paragraph>
 <paragraph index="729" node_type="writer">7.Implement two stacks using a single array. One stack should grow upward from the bottom of the array, while the other stack should grow downward from the top of the array. Design the following operations for each stack:</paragraph>
 <paragraph index="730" node_type="writer"> a) push1(value): Inserts the given value into the first stack.</paragraph>
 <paragraph index="731" node_type="writer"> b) push2(value): Inserts the given value into the second stack.</paragraph>
 <paragraph index="732" node_type="writer">c) pop1(): Removes and returns the top element from the first stack.</paragraph>
 <paragraph index="733" node_type="writer">d) pop2(): Removes and returns the top element from the second stack.</paragraph>
 <paragraph index="734" node_type="writer"> e) The class should handle stack overflow and underflow conditions, raising appropriate exceptions when necessary.</paragraph>
 <paragraph index="737" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="738" node_type="writer">#include &lt;stdbool.h&gt;</paragraph>
 <paragraph index="740" node_type="writer">#define MAX_SIZE 100</paragraph>
 <paragraph index="742" node_type="writer">int stack[MAX_SIZE];</paragraph>
 <paragraph index="743" node_type="writer">int top1 = -1; // Top index for the first stack</paragraph>
 <paragraph index="744" node_type="writer">int top2 = MAX_SIZE; // Top index for the second stack</paragraph>
 <paragraph index="746" node_type="writer">void push1(int value) {</paragraph>
 <paragraph index="747" node_type="writer">if (top1 + 1 == top2) {</paragraph>
 <paragraph index="748" node_type="writer">printf(&quot;Stack overflow: Cannot push element into the first stack\n&quot;);</paragraph>
 <paragraph index="749" node_type="writer">return;</paragraph>
 <paragraph index="750" node_type="writer">}</paragraph>
 <paragraph index="751" node_type="writer">top1++;</paragraph>
 <paragraph index="752" node_type="writer">stack[top1] = value;</paragraph>
 <paragraph index="753" node_type="writer">printf(&quot;Pushed %d into the first stack\n&quot;, value);</paragraph>
 <paragraph index="754" node_type="writer">}</paragraph>
 <paragraph index="756" node_type="writer">void push2(int value) {</paragraph>
 <paragraph index="757" node_type="writer">if (top2 - 1 == top1) {</paragraph>
 <paragraph index="758" node_type="writer">printf(&quot;Stack overflow: Cannot push element into the second stack\n&quot;);</paragraph>
 <paragraph index="759" node_type="writer">return;</paragraph>
 <paragraph index="760" node_type="writer">}</paragraph>
 <paragraph index="761" node_type="writer">top2--;</paragraph>
 <paragraph index="762" node_type="writer">stack[top2] = value;</paragraph>
 <paragraph index="763" node_type="writer">printf(&quot;Pushed %d into the second stack\n&quot;, value);</paragraph>
 <paragraph index="764" node_type="writer">}</paragraph>
 <paragraph index="766" node_type="writer">int pop1() {</paragraph>
 <paragraph index="767" node_type="writer">if (top1 == -1) {</paragraph>
 <paragraph index="768" node_type="writer">printf(&quot;Stack underflow: Cannot pop element from the first stack\n&quot;);</paragraph>
 <paragraph index="769" node_type="writer">return -1;</paragraph>
 <paragraph index="770" node_type="writer">}</paragraph>
 <paragraph index="771" node_type="writer">int poppedValue = stack[top1];</paragraph>
 <paragraph index="772" node_type="writer">top1--;</paragraph>
 <paragraph index="773" node_type="writer">return poppedValue;</paragraph>
 <paragraph index="774" node_type="writer">}</paragraph>
 <paragraph index="776" node_type="writer">int pop2() {</paragraph>
 <paragraph index="777" node_type="writer">if (top2 == MAX_SIZE) {</paragraph>
 <paragraph index="778" node_type="writer">printf(&quot;Stack underflow: Cannot pop element from the second stack\n&quot;);</paragraph>
 <paragraph index="779" node_type="writer">return -1;</paragraph>
 <paragraph index="780" node_type="writer">}</paragraph>
 <paragraph index="781" node_type="writer">int poppedValue = stack[top2];</paragraph>
 <paragraph index="782" node_type="writer">top2++;</paragraph>
 <paragraph index="783" node_type="writer">return poppedValue;</paragraph>
 <paragraph index="784" node_type="writer">}</paragraph>
 <paragraph index="786" node_type="writer">void displayStacks() {</paragraph>
 <paragraph index="787" node_type="writer">printf(&quot;First Stack: &quot;);</paragraph>
 <paragraph index="788" node_type="writer">if (top1 == -1) {</paragraph>
 <paragraph index="789" node_type="writer">printf(&quot;Empty&quot;);</paragraph>
 <paragraph index="790" node_type="writer">} else {</paragraph>
 <paragraph index="791" node_type="writer">for (int i = 0; i &lt;= top1; i++) {</paragraph>
 <paragraph index="792" node_type="writer">printf(&quot;%d &quot;, stack[i]);</paragraph>
 <paragraph index="793" node_type="writer">}</paragraph>
 <paragraph index="794" node_type="writer">}</paragraph>
 <paragraph index="795" node_type="writer">printf(&quot;\n&quot;);</paragraph>
 <paragraph index="796" node_type="writer">printf(&quot;Second Stack: &quot;);</paragraph>
 <paragraph index="797" node_type="writer">if (top2 == MAX_SIZE) {</paragraph>
 <paragraph index="798" node_type="writer">printf(&quot;Empty&quot;);</paragraph>
 <paragraph index="799" node_type="writer">} else {</paragraph>
 <paragraph index="800" node_type="writer">for (int i = MAX_SIZE - 1; i &gt;= top2; i--) {</paragraph>
 <paragraph index="801" node_type="writer">printf(&quot;%d &quot;, stack[i]);</paragraph>
 <paragraph index="802" node_type="writer">}</paragraph>
 <paragraph index="803" node_type="writer">}</paragraph>
 <paragraph index="804" node_type="writer">printf(&quot;\n&quot;);</paragraph>
 <paragraph index="805" node_type="writer">}</paragraph>
 <paragraph index="807" node_type="writer">int main() {</paragraph>
 <paragraph index="808" node_type="writer">int choice, stackNum, value;</paragraph>
 <paragraph index="809" node_type="writer">while (true) {</paragraph>
 <paragraph index="810" node_type="writer">printf(&quot;\nStack Operations\n&quot;);</paragraph>
 <paragraph index="811" node_type="writer">printf(&quot;1. Push to Stack 1\n&quot;);</paragraph>
 <paragraph index="812" node_type="writer">printf(&quot;2. Push to Stack 2\n&quot;);</paragraph>
 <paragraph index="813" node_type="writer">printf(&quot;3. Pop from Stack 1\n&quot;);</paragraph>
 <paragraph index="814" node_type="writer">printf(&quot;4. Pop from Stack 2\n&quot;);</paragraph>
 <paragraph index="815" node_type="writer">printf(&quot;5. Display Stacks\n&quot;);</paragraph>
 <paragraph index="816" node_type="writer">printf(&quot;0. Exit\n&quot;);</paragraph>
 <paragraph index="817" node_type="writer">printf(&quot;Enter your choice: &quot;);</paragraph>
 <paragraph index="818" node_type="writer">scanf(&quot;%d&quot;, &amp;choice);</paragraph>
 <paragraph index="819" node_type="writer">switch (choice) {</paragraph>
 <paragraph index="820" node_type="writer">case 0:</paragraph>
 <paragraph index="821" node_type="writer">printf(&quot;Exiting the program\n&quot;);</paragraph>
 <paragraph index="822" node_type="writer">return 0;</paragraph>
 <paragraph index="823" node_type="writer">case 1:</paragraph>
 <paragraph index="824" node_type="writer">printf(&quot;Enter the value to push: &quot;);</paragraph>
 <paragraph index="825" node_type="writer">scanf(&quot;%d&quot;, &amp;value);</paragraph>
 <paragraph index="826" node_type="writer">push1(value);</paragraph>
 <paragraph index="827" node_type="writer">break;</paragraph>
 <paragraph index="828" node_type="writer">case 2:</paragraph>
 <paragraph index="829" node_type="writer">printf(&quot;Enter the value to push: &quot;);</paragraph>
 <paragraph index="830" node_type="writer">scanf(&quot;%d&quot;, &amp;value);</paragraph>
 <paragraph index="831" node_type="writer">push2(value);</paragraph>
 <paragraph index="832" node_type="writer">break;</paragraph>
 <paragraph index="833" node_type="writer">case 3:</paragraph>
 <paragraph index="834" node_type="writer">value = pop1();</paragraph>
 <paragraph index="835" node_type="writer">if (value != -1) {</paragraph>
 <paragraph index="836" node_type="writer">printf(&quot;Popped %d from the first stack\n&quot;, value);</paragraph>
 <paragraph index="837" node_type="writer">}</paragraph>
 <paragraph index="838" node_type="writer">break;</paragraph>
 <paragraph index="839" node_type="writer">case 4:</paragraph>
 <paragraph index="840" node_type="writer">value = pop2();</paragraph>
 <paragraph index="841" node_type="writer">if (value != -1) {</paragraph>
 <paragraph index="842" node_type="writer">printf(&quot;Popped %d from the second stack\n&quot;, value);</paragraph>
 <paragraph index="843" node_type="writer">}</paragraph>
 <paragraph index="844" node_type="writer">break;</paragraph>
 <paragraph index="845" node_type="writer">case 5:</paragraph>
 <paragraph index="846" node_type="writer">displayStacks();</paragraph>
 <paragraph index="847" node_type="writer">break;</paragraph>
 <paragraph index="848" node_type="writer">default:</paragraph>
 <paragraph index="849" node_type="writer">printf(&quot;Invalid choice\n&quot;);</paragraph>
 <paragraph index="850" node_type="writer">}</paragraph>
 <paragraph index="851" node_type="writer">}</paragraph>
 <paragraph index="852" node_type="writer">}</paragraph>
 <paragraph index="854" node_type="writer">Output</paragraph>
 <paragraph index="917" node_type="writer">8.Write a program to implement the conversions between infix and prefix/postfix expressions, as well as evaluates prefix and postfix expressions. Your program should utilize the stack data structure to perform these operations efficiently. Design the following functionalities:</paragraph>
 <paragraph index="920" node_type="writer">a. infix_to_prefix(expression): This method takes an infix expression as input and converts it to its equivalent prefix notation. The infix expression will consist of arithmetic operators (+, -, *, /), parentheses (,), and operands (single-digit integers).</paragraph>
 <paragraph index="923" node_type="writer">b. infix_to_postfix(expression): This method takes an infix expression as input and converts it to its equivalent postfix notation.</paragraph>
 <paragraph index="926" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="927" node_type="writer">#include &lt;stdlib.h&gt;</paragraph>
 <paragraph index="928" node_type="writer">#include &lt;stdbool.h&gt;</paragraph>
 <paragraph index="929" node_type="writer">#include &lt;string.h&gt;</paragraph>
 <paragraph index="930" node_type="writer">#include &lt;ctype.h&gt;</paragraph>
 <paragraph index="932" node_type="writer">#define MAX_SIZE 100</paragraph>
 <paragraph index="934" node_type="writer">struct Stack {</paragraph>
 <paragraph index="935" node_type="writer">int top;</paragraph>
 <paragraph index="936" node_type="writer">char items[MAX_SIZE];</paragraph>
 <paragraph index="937" node_type="writer">};</paragraph>
 <paragraph index="939" node_type="writer">void initializeStack(struct Stack* stack) {</paragraph>
 <paragraph index="940" node_type="writer">stack-&gt;top = -1;</paragraph>
 <paragraph index="941" node_type="writer">}</paragraph>
 <paragraph index="943" node_type="writer">bool isStackEmpty(struct Stack* stack) {</paragraph>
 <paragraph index="944" node_type="writer">return (stack-&gt;top == -1);</paragraph>
 <paragraph index="945" node_type="writer">}</paragraph>
 <paragraph index="947" node_type="writer">bool isStackFull(struct Stack* stack) {</paragraph>
 <paragraph index="948" node_type="writer">return (stack-&gt;top == MAX_SIZE - 1);</paragraph>
 <paragraph index="949" node_type="writer">}</paragraph>
 <paragraph index="951" node_type="writer">void push(struct Stack* stack, char value) {</paragraph>
 <paragraph index="952" node_type="writer">if (isStackFull(stack)) {</paragraph>
 <paragraph index="953" node_type="writer">printf(&quot;Stack overflow: Cannot push element\n&quot;);</paragraph>
 <paragraph index="954" node_type="writer">return;</paragraph>
 <paragraph index="955" node_type="writer">}</paragraph>
 <paragraph index="957" node_type="writer">stack-&gt;top++;</paragraph>
 <paragraph index="958" node_type="writer">stack-&gt;items[stack-&gt;top] = value;</paragraph>
 <paragraph index="959" node_type="writer">}</paragraph>
 <paragraph index="961" node_type="writer">char pop(struct Stack* stack) {</paragraph>
 <paragraph index="962" node_type="writer">if (isStackEmpty(stack)) {</paragraph>
 <paragraph index="963" node_type="writer">printf(&quot;Stack underflow: Cannot pop element\n&quot;);</paragraph>
 <paragraph index="964" node_type="writer">return '\0';</paragraph>
 <paragraph index="965" node_type="writer">}</paragraph>
 <paragraph index="967" node_type="writer">char poppedValue = stack-&gt;items[stack-&gt;top];</paragraph>
 <paragraph index="968" node_type="writer">stack-&gt;top--;</paragraph>
 <paragraph index="969" node_type="writer">return poppedValue;</paragraph>
 <paragraph index="970" node_type="writer">}</paragraph>
 <paragraph index="972" node_type="writer">char peek(struct Stack* stack) {</paragraph>
 <paragraph index="973" node_type="writer">if (isStackEmpty(stack)) {</paragraph>
 <paragraph index="974" node_type="writer">return '\0';</paragraph>
 <paragraph index="975" node_type="writer">}</paragraph>
 <paragraph index="977" node_type="writer">return stack-&gt;items[stack-&gt;top];</paragraph>
 <paragraph index="978" node_type="writer">}</paragraph>
 <paragraph index="980" node_type="writer">int getPrecedence(char operator) {</paragraph>
 <paragraph index="981" node_type="writer">switch (operator) {</paragraph>
 <paragraph index="982" node_type="writer">case '+':</paragraph>
 <paragraph index="983" node_type="writer">case '-':</paragraph>
 <paragraph index="984" node_type="writer">return 1;</paragraph>
 <paragraph index="985" node_type="writer">case '*':</paragraph>
 <paragraph index="986" node_type="writer">case '/':</paragraph>
 <paragraph index="987" node_type="writer">return 2;</paragraph>
 <paragraph index="988" node_type="writer">default:</paragraph>
 <paragraph index="989" node_type="writer">return 0;</paragraph>
 <paragraph index="990" node_type="writer">}</paragraph>
 <paragraph index="991" node_type="writer">}</paragraph>
 <paragraph index="993" node_type="writer">bool isOperator(char symbol) {</paragraph>
 <paragraph index="994" node_type="writer">return (symbol == '+' || symbol == '-' || symbol == '*' || symbol == '/');</paragraph>
 <paragraph index="995" node_type="writer">}</paragraph>
 <paragraph index="997" node_type="writer">bool isOperand(char symbol) {</paragraph>
 <paragraph index="998" node_type="writer">return (isalpha(symbol) || isdigit(symbol));</paragraph>
 <paragraph index="999" node_type="writer">}</paragraph>
 <paragraph index="1001" node_type="writer">char* infix_to_prefix(char* expression) {</paragraph>
 <paragraph index="1002" node_type="writer">int length = strlen(expression);</paragraph>
 <paragraph index="1003" node_type="writer">struct Stack operatorStack;</paragraph>
 <paragraph index="1004" node_type="writer">struct Stack resultStack;</paragraph>
 <paragraph index="1006" node_type="writer">initializeStack(&amp;operatorStack);</paragraph>
 <paragraph index="1007" node_type="writer">initializeStack(&amp;resultStack);</paragraph>
 <paragraph index="1009" node_type="writer">for (int i = length - 1; i &gt;= 0; i--) {</paragraph>
 <paragraph index="1010" node_type="writer">char symbol = expression[i];</paragraph>
 <paragraph index="1012" node_type="writer">if (symbol == ' ' || symbol == '\t') {</paragraph>
 <paragraph index="1013" node_type="writer">continue;</paragraph>
 <paragraph index="1014" node_type="writer">}</paragraph>
 <paragraph index="1016" node_type="writer">if (isOperand(symbol)) {</paragraph>
 <paragraph index="1017" node_type="writer">push(&amp;resultStack, symbol);</paragraph>
 <paragraph index="1018" node_type="writer">} else if (symbol == ')') {</paragraph>
 <paragraph index="1019" node_type="writer">push(&amp;operatorStack, symbol);</paragraph>
 <paragraph index="1020" node_type="writer">} else if (symbol == '(') {</paragraph>
 <paragraph index="1021" node_type="writer">while (peek(&amp;operatorStack) != ')' &amp;&amp; !isStackEmpty(&amp;operatorStack)) {</paragraph>
 <paragraph index="1022" node_type="writer">char poppedOperator = pop(&amp;operatorStack);</paragraph>
 <paragraph index="1023" node_type="writer">push(&amp;resultStack, poppedOperator);</paragraph>
 <paragraph index="1024" node_type="writer">}</paragraph>
 <paragraph index="1026" node_type="writer">if (peek(&amp;operatorStack) == ')') {</paragraph>
 <paragraph index="1027" node_type="writer">pop(&amp;operatorStack);</paragraph>
 <paragraph index="1028" node_type="writer">}</paragraph>
 <paragraph index="1029" node_type="writer">} else if (isOperator(symbol)) {</paragraph>
 <paragraph index="1030" node_type="writer">while (!isStackEmpty(&amp;operatorStack) &amp;&amp; getPrecedence(symbol) &lt; getPrecedence(peek(&amp;operatorStack))) {</paragraph>
 <paragraph index="1031" node_type="writer">char poppedOperator = pop(&amp;operatorStack);</paragraph>
 <paragraph index="1032" node_type="writer">push(&amp;resultStack, poppedOperator);</paragraph>
 <paragraph index="1033" node_type="writer">}</paragraph>
 <paragraph index="1035" node_type="writer">push(&amp;operatorStack, symbol);</paragraph>
 <paragraph index="1036" node_type="writer">}</paragraph>
 <paragraph index="1037" node_type="writer">}</paragraph>
 <paragraph index="1039" node_type="writer">while (!isStackEmpty(&amp;operatorStack)) {</paragraph>
 <paragraph index="1040" node_type="writer">char poppedOperator = pop(&amp;operatorStack);</paragraph>
 <paragraph index="1041" node_type="writer">push(&amp;resultStack, poppedOperator);</paragraph>
 <paragraph index="1042" node_type="writer">}</paragraph>
 <paragraph index="1044" node_type="writer">char* prefixExpression = (char*)malloc((resultStack.top + 2) * sizeof(char));</paragraph>
 <paragraph index="1045" node_type="writer">int index = 0;</paragraph>
 <paragraph index="1047" node_type="writer">while (!isStackEmpty(&amp;resultStack)) {</paragraph>
 <paragraph index="1048" node_type="writer">prefixExpression[index] = pop(&amp;resultStack);</paragraph>
 <paragraph index="1049" node_type="writer">index++;</paragraph>
 <paragraph index="1050" node_type="writer">}</paragraph>
 <paragraph index="1052" node_type="writer">prefixExpression[index] = '\0';</paragraph>
 <paragraph index="1054" node_type="writer">return prefixExpression;</paragraph>
 <paragraph index="1055" node_type="writer">}</paragraph>
 <paragraph index="1057" node_type="writer">char* infix_to_postfix(char* expression) {</paragraph>
 <paragraph index="1058" node_type="writer">int length = strlen(expression);</paragraph>
 <paragraph index="1059" node_type="writer">struct Stack operatorStack;</paragraph>
 <paragraph index="1060" node_type="writer">char* postfixExpression = (char*)malloc((length + 1) * sizeof(char)); // Allocate memory for the postfix expression</paragraph>
 <paragraph index="1061" node_type="writer">int postfixIndex = 0;</paragraph>
 <paragraph index="1063" node_type="writer">initializeStack(&amp;operatorStack);</paragraph>
 <paragraph index="1065" node_type="writer">for (int i = 0; i &lt; length; i++) {</paragraph>
 <paragraph index="1066" node_type="writer">char symbol = expression[i];</paragraph>
 <paragraph index="1068" node_type="writer">if (symbol == ' ' || symbol == '\t') {</paragraph>
 <paragraph index="1069" node_type="writer">continue;</paragraph>
 <paragraph index="1070" node_type="writer">}</paragraph>
 <paragraph index="1072" node_type="writer">if (isOperand(symbol)) {</paragraph>
 <paragraph index="1073" node_type="writer">postfixExpression[postfixIndex] = symbol;</paragraph>
 <paragraph index="1074" node_type="writer">postfixIndex++;</paragraph>
 <paragraph index="1075" node_type="writer">} else if (symbol == '(') {</paragraph>
 <paragraph index="1076" node_type="writer">push(&amp;operatorStack, symbol);</paragraph>
 <paragraph index="1077" node_type="writer">} else if (symbol == ')') {</paragraph>
 <paragraph index="1078" node_type="writer">while (peek(&amp;operatorStack) != '(' &amp;&amp; !isStackEmpty(&amp;operatorStack)) {</paragraph>
 <paragraph index="1079" node_type="writer">char poppedOperator = pop(&amp;operatorStack);</paragraph>
 <paragraph index="1080" node_type="writer">postfixExpression[postfixIndex] = poppedOperator;</paragraph>
 <paragraph index="1081" node_type="writer">postfixIndex++;</paragraph>
 <paragraph index="1082" node_type="writer">}</paragraph>
 <paragraph index="1084" node_type="writer">if (peek(&amp;operatorStack) == '(') {</paragraph>
 <paragraph index="1085" node_type="writer">pop(&amp;operatorStack);</paragraph>
 <paragraph index="1086" node_type="writer">}</paragraph>
 <paragraph index="1087" node_type="writer">} else if (isOperator(symbol)) {</paragraph>
 <paragraph index="1088" node_type="writer">while (!isStackEmpty(&amp;operatorStack) &amp;&amp; getPrecedence(symbol) &lt;= getPrecedence(peek(&amp;operatorStack))) {</paragraph>
 <paragraph index="1089" node_type="writer">char poppedOperator = pop(&amp;operatorStack);</paragraph>
 <paragraph index="1090" node_type="writer">postfixExpression[postfixIndex] = poppedOperator;</paragraph>
 <paragraph index="1091" node_type="writer">postfixIndex++;</paragraph>
 <paragraph index="1092" node_type="writer">}</paragraph>
 <paragraph index="1094" node_type="writer">push(&amp;operatorStack, symbol);</paragraph>
 <paragraph index="1095" node_type="writer">}</paragraph>
 <paragraph index="1096" node_type="writer">}</paragraph>
 <paragraph index="1098" node_type="writer">while (!isStackEmpty(&amp;operatorStack)) {</paragraph>
 <paragraph index="1099" node_type="writer">char poppedOperator = pop(&amp;operatorStack);</paragraph>
 <paragraph index="1100" node_type="writer">postfixExpression[postfixIndex] = poppedOperator;</paragraph>
 <paragraph index="1101" node_type="writer">postfixIndex++;</paragraph>
 <paragraph index="1102" node_type="writer">}</paragraph>
 <paragraph index="1104" node_type="writer">postfixExpression[postfixIndex] = '\0';</paragraph>
 <paragraph index="1106" node_type="writer">return postfixExpression;</paragraph>
 <paragraph index="1107" node_type="writer">}</paragraph>
 <paragraph index="1109" node_type="writer">int main() {</paragraph>
 <paragraph index="1110" node_type="writer">int _caseOperator;</paragraph>
 <paragraph index="1111" node_type="writer">char expression[MAX_SIZE];</paragraph>
 <paragraph index="1112" node_type="writer">printf(&quot;Enter the infix expression: &quot;);</paragraph>
 <paragraph index="1113" node_type="writer">fgets(expression, sizeof(expression), stdin);</paragraph>
 <paragraph index="1114" node_type="writer">expression[strcspn(expression, &quot;\n&quot;)] = '\0'; // Remove the trailing newline character</paragraph>
 <paragraph index="1116" node_type="writer">printf(&quot;How would you wish to evaluate the given expression: \n&quot;);</paragraph>
 <paragraph index="1117" node_type="writer">printf(&quot;1.infix to prefix\n&quot;);</paragraph>
 <paragraph index="1118" node_type="writer">printf(&quot;2.infix to postfix\n&quot;);</paragraph>
 <paragraph index="1120" node_type="writer">scanf(&quot;%d&quot;,&amp;_caseOperator);</paragraph>
 <paragraph index="1122" node_type="writer">switch(_caseOperator){</paragraph>
 <paragraph index="1123" node_type="writer">case 1:</paragraph>
 <paragraph index="1124" node_type="writer">char* prefixExpression = infix_to_prefix(expression);</paragraph>
 <paragraph index="1125" node_type="writer">printf(&quot;Prefix expression: %s\n&quot;, prefixExpression);</paragraph>
 <paragraph index="1126" node_type="writer">free(prefixExpression);</paragraph>
 <paragraph index="1127" node_type="writer">break;</paragraph>
 <paragraph index="1128" node_type="writer">case 2:</paragraph>
 <paragraph index="1129" node_type="writer">char* postfixExpression = infix_to_postfix(expression);</paragraph>
 <paragraph index="1131" node_type="writer">printf(&quot;Postfix expression: %s\n&quot;, postfixExpression);</paragraph>
 <paragraph index="1133" node_type="writer">free(postfixExpression);</paragraph>
 <paragraph index="1135" node_type="writer">printf(&quot;exp&quot;);</paragraph>
 <paragraph index="1136" node_type="writer">break;</paragraph>
 <paragraph index="1137" node_type="writer">default:</paragraph>
 <paragraph index="1138" node_type="writer">printf(&quot;invalid operation&quot;);</paragraph>
 <paragraph index="1140" node_type="writer">}</paragraph>
 <paragraph index="1142" node_type="writer">return 0;</paragraph>
 <paragraph index="1143" node_type="writer">}</paragraph>
 <paragraph index="1145" node_type="writer">Output for infix to prefix</paragraph>
 <paragraph index="1184" node_type="writer">Output for infix to postfix</paragraph>
 <paragraph index="1220" node_type="writer">c. evaluate_prefix(expression): This method takes a prefix expression as input and evaluates it, returning the result.</paragraph>
 <paragraph index="1222" node_type="writer">d. evaluate_postfix(expression): This method takes a postfix expression as input and evaluates it, returning the result.</paragraph>
 <paragraph index="1225" node_type="writer">#include &lt;stdio.h&gt;</paragraph>
 <paragraph index="1226" node_type="writer">#include &lt;stdlib.h&gt;</paragraph>
 <paragraph index="1227" node_type="writer">#include &lt;string.h&gt;</paragraph>
 <paragraph index="1228" node_type="writer">#include &lt;ctype.h&gt;</paragraph>
 <paragraph index="1230" node_type="writer">#define MAX_SIZE 100</paragraph>
 <paragraph index="1232" node_type="writer">typedef struct {</paragraph>
 <paragraph index="1233" node_type="writer">int top;</paragraph>
 <paragraph index="1234" node_type="writer">double items[MAX_SIZE];</paragraph>
 <paragraph index="1235" node_type="writer">} Stack;</paragraph>
 <paragraph index="1237" node_type="writer">void initializeStack(Stack *s) {</paragraph>
 <paragraph index="1238" node_type="writer">s-&gt;top = -1;</paragraph>
 <paragraph index="1239" node_type="writer">}</paragraph>
 <paragraph index="1241" node_type="writer">int isEmpty(Stack *s) {</paragraph>
 <paragraph index="1242" node_type="writer">return s-&gt;top == -1;</paragraph>
 <paragraph index="1243" node_type="writer">}</paragraph>
 <paragraph index="1245" node_type="writer">int isFull(Stack *s) {</paragraph>
 <paragraph index="1246" node_type="writer">return s-&gt;top == MAX_SIZE - 1;</paragraph>
 <paragraph index="1247" node_type="writer">}</paragraph>
 <paragraph index="1249" node_type="writer">void push(Stack *s, double value) {</paragraph>
 <paragraph index="1250" node_type="writer">if (isFull(s)) {</paragraph>
 <paragraph index="1251" node_type="writer">printf(&quot;Stack overflow!\n&quot;);</paragraph>
 <paragraph index="1252" node_type="writer">exit(1);</paragraph>
 <paragraph index="1253" node_type="writer">}</paragraph>
 <paragraph index="1254" node_type="writer">s-&gt;items[++(s-&gt;top)] = value;</paragraph>
 <paragraph index="1255" node_type="writer">}</paragraph>
 <paragraph index="1257" node_type="writer">double pop(Stack *s) {</paragraph>
 <paragraph index="1258" node_type="writer">if (isEmpty(s)) {</paragraph>
 <paragraph index="1259" node_type="writer">printf(&quot;Stack underflow!\n&quot;);</paragraph>
 <paragraph index="1260" node_type="writer">exit(1);</paragraph>
 <paragraph index="1261" node_type="writer">}</paragraph>
 <paragraph index="1262" node_type="writer">return s-&gt;items[(s-&gt;top)--];</paragraph>
 <paragraph index="1263" node_type="writer">}</paragraph>
 <paragraph index="1265" node_type="writer">double evaluatePostfix(char *expression) {</paragraph>
 <paragraph index="1266" node_type="writer">Stack stack;</paragraph>
 <paragraph index="1267" node_type="writer">initializeStack(&amp;stack);</paragraph>
 <paragraph index="1268" node_type="writer">int len = strlen(expression);</paragraph>
 <paragraph index="1269" node_type="writer">int i;</paragraph>
 <paragraph index="1270" node_type="writer">double operand1, operand2;</paragraph>
 <paragraph index="1272" node_type="writer">for (i = 0; i &lt; len; i++) {</paragraph>
 <paragraph index="1273" node_type="writer">if (isdigit(expression[i])) {</paragraph>
 <paragraph index="1274" node_type="writer">double num = 0;</paragraph>
 <paragraph index="1275" node_type="writer">while (isdigit(expression[i])) {</paragraph>
 <paragraph index="1276" node_type="writer">num = num * 10 + (expression[i] - '0');</paragraph>
 <paragraph index="1277" node_type="writer">i++;</paragraph>
 <paragraph index="1278" node_type="writer">}</paragraph>
 <paragraph index="1279" node_type="writer">i--;</paragraph>
 <paragraph index="1280" node_type="writer">push(&amp;stack, num);</paragraph>
 <paragraph index="1281" node_type="writer">} else if (expression[i] != ' ') {</paragraph>
 <paragraph index="1282" node_type="writer">operand2 = pop(&amp;stack);</paragraph>
 <paragraph index="1283" node_type="writer">operand1 = pop(&amp;stack);</paragraph>
 <paragraph index="1284" node_type="writer">switch (expression[i]) {</paragraph>
 <paragraph index="1285" node_type="writer">case '+':</paragraph>
 <paragraph index="1286" node_type="writer">push(&amp;stack, operand1 + operand2);</paragraph>
 <paragraph index="1287" node_type="writer">break;</paragraph>
 <paragraph index="1288" node_type="writer">case '-':</paragraph>
 <paragraph index="1289" node_type="writer">push(&amp;stack, operand1 - operand2);</paragraph>
 <paragraph index="1290" node_type="writer">break;</paragraph>
 <paragraph index="1291" node_type="writer">case '*':</paragraph>
 <paragraph index="1292" node_type="writer">push(&amp;stack, operand1 * operand2);</paragraph>
 <paragraph index="1293" node_type="writer">break;</paragraph>
 <paragraph index="1294" node_type="writer">case '/':</paragraph>
 <paragraph index="1295" node_type="writer">push(&amp;stack, operand1 / operand2);</paragraph>
 <paragraph index="1296" node_type="writer">break;</paragraph>
 <paragraph index="1297" node_type="writer">default:</paragraph>
 <paragraph index="1298" node_type="writer">printf(&quot;Invalid operator!\n&quot;);</paragraph>
 <paragraph index="1299" node_type="writer">exit(1);</paragraph>
 <paragraph index="1300" node_type="writer">}</paragraph>
 <paragraph index="1301" node_type="writer">}</paragraph>
 <paragraph index="1302" node_type="writer">}</paragraph>
 <paragraph index="1303" node_type="writer">return pop(&amp;stack);</paragraph>
 <paragraph index="1304" node_type="writer">}</paragraph>
 <paragraph index="1306" node_type="writer">double evaluatePrefix(char *expression) {</paragraph>
 <paragraph index="1307" node_type="writer">Stack stack;</paragraph>
 <paragraph index="1308" node_type="writer">initializeStack(&amp;stack);</paragraph>
 <paragraph index="1309" node_type="writer">int len = strlen(expression);</paragraph>
 <paragraph index="1310" node_type="writer">int i;</paragraph>
 <paragraph index="1311" node_type="writer">double operand1, operand2;</paragraph>
 <paragraph index="1313" node_type="writer">for (i = len - 1; i &gt;= 0; i--) {</paragraph>
 <paragraph index="1314" node_type="writer">if (isdigit(expression[i])) {</paragraph>
 <paragraph index="1315" node_type="writer">double num = 0;</paragraph>
 <paragraph index="1316" node_type="writer">while (isdigit(expression[i])) {</paragraph>
 <paragraph index="1317" node_type="writer">num = num * 10 + (expression[i] - '0');</paragraph>
 <paragraph index="1318" node_type="writer">i--;</paragraph>
 <paragraph index="1319" node_type="writer">}</paragraph>
 <paragraph index="1320" node_type="writer">i++;</paragraph>
 <paragraph index="1321" node_type="writer">push(&amp;stack, num);</paragraph>
 <paragraph index="1322" node_type="writer">} else if (expression[i] != ' ') {</paragraph>
 <paragraph index="1323" node_type="writer">operand1 = pop(&amp;stack);</paragraph>
 <paragraph index="1324" node_type="writer">operand2 = pop(&amp;stack);</paragraph>
 <paragraph index="1325" node_type="writer">switch (expression[i]) {</paragraph>
 <paragraph index="1326" node_type="writer">case '+':</paragraph>
 <paragraph index="1327" node_type="writer">push(&amp;stack, operand2 + operand1);</paragraph>
 <paragraph index="1328" node_type="writer">break;</paragraph>
 <paragraph index="1329" node_type="writer">case '-':</paragraph>
 <paragraph index="1330" node_type="writer">push(&amp;stack, operand2 - operand1);</paragraph>
 <paragraph index="1331" node_type="writer">break;</paragraph>
 <paragraph index="1332" node_type="writer">case '*':</paragraph>
 <paragraph index="1333" node_type="writer">push(&amp;stack, operand2 * operand1);</paragraph>
 <paragraph index="1334" node_type="writer">break;</paragraph>
 <paragraph index="1335" node_type="writer">case '/':</paragraph>
 <paragraph index="1336" node_type="writer">push(&amp;stack, operand2 / operand1);</paragraph>
 <paragraph index="1337" node_type="writer">break;</paragraph>
 <paragraph index="1338" node_type="writer">default:</paragraph>
 <paragraph index="1339" node_type="writer">printf(&quot;Invalid operator!\n&quot;);</paragraph>
 <paragraph index="1340" node_type="writer">exit(1);</paragraph>
 <paragraph index="1341" node_type="writer">}</paragraph>
 <paragraph index="1342" node_type="writer">}</paragraph>
 <paragraph index="1343" node_type="writer">}</paragraph>
 <paragraph index="1344" node_type="writer">return pop(&amp;stack);</paragraph>
 <paragraph index="1345" node_type="writer">}</paragraph>
 <paragraph index="1347" node_type="writer">int main() {</paragraph>
 <paragraph index="1348" node_type="writer">int caseOperator;</paragraph>
 <paragraph index="1349" node_type="writer">char expression[100];</paragraph>
 <paragraph index="1350" node_type="writer">double result;</paragraph>
 <paragraph index="1352" node_type="writer">printf(&quot;Menu:\n&quot;);</paragraph>
 <paragraph index="1353" node_type="writer">printf(&quot;1. Evaluate postfix expression\n&quot;);</paragraph>
 <paragraph index="1354" node_type="writer">printf(&quot;2. Evaluate prefix expression\n&quot;);</paragraph>
 <paragraph index="1355" node_type="writer">printf(&quot;3. Exit\n&quot;);</paragraph>
 <paragraph index="1357" node_type="writer">while (1) {</paragraph>
 <paragraph index="1358" node_type="writer">printf(&quot;\nEnter your choice: &quot;);</paragraph>
 <paragraph index="1359" node_type="writer">scanf(&quot;%d&quot;, &amp;caseOperator);</paragraph>
 <paragraph index="1361" node_type="writer">switch (caseOperator) {</paragraph>
 <paragraph index="1362" node_type="writer">case 1:</paragraph>
 <paragraph index="1363" node_type="writer">printf(&quot;Enter a postfix expression: &quot;);</paragraph>
 <paragraph index="1364" node_type="writer">scanf(&quot; %[^\n]&quot;, expression);</paragraph>
 <paragraph index="1365" node_type="writer">printf(&quot;Result: %lf\n&quot;, evaluatePostfix(expression));</paragraph>
 <paragraph index="1366" node_type="writer">break;</paragraph>
 <paragraph index="1367" node_type="writer">case 2:</paragraph>
 <paragraph index="1368" node_type="writer">printf(&quot;Enter a prefix expression: &quot;);</paragraph>
 <paragraph index="1369" node_type="writer">scanf(&quot; %[^\n]&quot;, expression);</paragraph>
 <paragraph index="1370" node_type="writer">printf(&quot;Result: %lf\n&quot;, evaluatePrefix(expression));</paragraph>
 <paragraph index="1371" node_type="writer">break;</paragraph>
 <paragraph index="1372" node_type="writer">case 3:</paragraph>
 <paragraph index="1373" node_type="writer">printf(&quot;Exiting...\n&quot;);</paragraph>
 <paragraph index="1374" node_type="writer">exit(0);</paragraph>
 <paragraph index="1375" node_type="writer">default:</paragraph>
 <paragraph index="1376" node_type="writer">printf(&quot;Invalid operator\n&quot;);</paragraph>
 <paragraph index="1377" node_type="writer">break;</paragraph>
 <paragraph index="1378" node_type="writer">}</paragraph>
 <paragraph index="1379" node_type="writer">}</paragraph>
 <paragraph index="1381" node_type="writer">return 0;</paragraph>
 <paragraph index="1382" node_type="writer">}</paragraph>
 <paragraph index="1386" node_type="writer">Output for postfix evaluation</paragraph>
 <paragraph index="1407" node_type="writer">Output for prefix evaluation</paragraph>
</indexing>
